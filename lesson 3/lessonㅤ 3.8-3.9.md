### 3.8 Функции `reindex`, `drop` и продвинутая индексация

---

#### 3.8.1-3.8.2 Неизменяемость объекта `Index`

И строки, и столбцы `DataFrame` представлены объектом `pd.Index`. Ключевое свойство этого объекта — **неизменяемость**. Вы не можете изменить отдельный элемент индекса напрямую. Это защищает от случайных ошибок.

**Пример:**
```python
df = pd.DataFrame(np.arange(4).reshape((2, 2)), 
                  index=['a', 'b'], 
                  columns=['Ohio', 'Texas'])

# Попытка изменить метку индекса напрямую вызовет ошибку
try:
    df.index[1] = 'd' # TypeError: Index does not support mutable operations
except TypeError as e:
    print(f"Ошибка: {e}")
```
Для изменения меток нужно использовать специальные методы, такие как `.reindex()` или переприсваивать весь индекс целиком.

---

#### 3.8.3 Изменение/переупорядочивание индексов: `reindex`

Метод `.reindex()` создает **новый** `DataFrame`, приводя его к новому набору меток по указанной оси.

**Синтаксис по умолчанию:**
`df.reindex(labels, axis=0)`

*   `labels`: Список меток, которые должны быть в новом `DataFrame`.
*   `axis`: Ось, по которой происходит переиндексация (`0` для строк, `1` для столбцов).

```python
# Переупорядочим строки, добавив новую ('c') и убрав старую ('b')
new_df = df.reindex(['a', 'c'])
print(new_df)
```
**Вывод:**
```
   Ohio  Texas
a   0.0    1.0
c   NaN    NaN  # <-- Новая строка, заполнена NaN
```
---

#### 3.8.4-3.8.5 Удаление строк/столбцов: `drop`

Метод `.drop()` используется для удаления данных по меткам.

**Синтаксис по умолчанию:**
`df.drop(labels, axis=0, inplace=False)`

*   `labels`: Одна метка или список меток для удаления.
*   `axis`: Ось, по которой удаляем (`0` для строк, `1` для столбцов).
*   `inplace`:
    *   `False` (по умолчанию): Возвращает **новый** `DataFrame` с удаленными данными. Исходный `df` не меняется.
    *   `True`: Удаляет данные **на месте** в исходном `df` и ничего не возвращает (`None`). **Используйте с осторожностью!**

```python
# Удаление строки 'a' (возвращает новый df)
df_after_drop = df.drop('a', axis=0)

# Удаление столбца 'Texas' на месте
df.drop('Texas', axis=1, inplace=True) 
```

---


#### 3.8.7-3.8.8 Индексация в `Series`

```python
s = pd.Series(np.arange(4.), index=['a', 'b', 'c', 'd'])

# Fancy indexing (выбор по списку меток)
print("Fancy indexing:\n", s[['c', 'a']])

# Boolean masking (фильтрация по условию)
mask = s > 2
print("\nBoolean mask:\n", s[mask])
```

#### 3.8.9-3.8.10 Слайсинг по меткам в `Series`

Как по мне, крайне спорная фича Pandas.

*   **Правило 1:** Слайсинг по меткам (`s['a':'c']`) **включает** правую границу.
*   **Правило 2:** Слайсинг идет по **физическому расположению** меток в `Series`, а не по их алфавитному порядку.

**Пример:**
```python
s1 = pd.Series([10, 20, 30, 40, 50, 60], index=['c', 'd', 'e', 'a', 'f', 'b'])

# Идет от 'a' до 'b' по порядку их следования в s1
print(s1['a':'b']) 
# Вывод:
# a    40
# f    50
# b    60

# Pandas не может найти 'c' после 'a', поэтому возвращает пустоту
print(s1['a':'c'])
# Вывод: Series([], dtype: int64)
```
На практике, чтобы избежать такого поведения, **лучше сначала отсортировать индекс** с помощью `s1.sort_index()` или использовать `.loc` для явного выбора.

#### 3.8.11 Выбор данных в `DataFrame`

Это основной способ фильтрации данных.

```python
df = pd.DataFrame(np.arange(16).reshape((4, 4)),
                  index=['Ohio', 'Colorado', 'Utah', 'New York'],
                  columns=['one', 'two', 'three', 'four'])

# A) Выбор столбцов по имени
print("Выбор одного столбца:\n", df['two'])
print("\nВыбор нескольких столбцов:\n", df[['three', 'one']])

# B) Выбор строк по срезу ИНДЕКСОВ (позиций)
print("\nВыбор первых двух строк:\n", df[:2])
#Примечание: для отдельных индексов вроде df[2] выдаёт ошибку

# C) Выбор строк по БУЛЕВОЙ МАСКЕ (фильтрация)
mask = df['three'] > 5
print("\nФильтрация (строки, где 'three' > 5):\n", df[mask])
```

---
#### 3.8.12-3.8.13 Двумерные маски и агрегация

**Двумерная маска:**
Можно применить булево условие ко всему `DataFrame`. Это создаст двумерную маску. При применении ее к `DataFrame` значения, где в маске `False`, заменятся на `NaN`.

```python
# Заменим все значения <= 5 на NaN
df_masked = df[df > 5]
print("DataFrame после 2D маскировки:\n", df_masked)
```
**Вывод:**
```
           one   two  three  four
Ohio       NaN   NaN    NaN   NaN
Colorado   NaN   NaN    7.0   NaN
Utah       8.0   9.0   10.0  11.0
New York  12.0  13.0   14.0  15.0
```

**Комбинация фильтрации и агрегации:**
*Похоже на `WHERE ... GROUP BY ... AGGREGATE` из SQL.*

**Задача:** *Найти среднее значение в столбце `four` только для тех строк, где значение в столбце `three` больше 5.*
```python
# 1. Фильтруем строки (как WHERE)
filtered_df = df[df['three'] > 5]

# 2. Выбираем нужный столбец
target_column = filtered_df['four']

# 3. Применяем агрегирующую функцию (как AVG)
result = target_column.mean()

# Можно записать в одну строку:
result_oneline = df[df['three'] > 5]['four'].mean()

print(f"\nСреднее значение: {result_oneline}") # (7 + 11 + 15) / 3 = 11.0
```
