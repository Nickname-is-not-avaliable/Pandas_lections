
### 3.6 Поподробнее про `DataFrame`: индексы, вложенные словари, `del` и `.T`

---

#### 3.6.1-3.6.3 Создание и присваивание данных

**Создание из вложенного словаря (3.6.5):**
Очень удобный способ, если у вас есть данные, сгруппированные по категориям. Pandas интерпретирует это так:
*   **Внешние ключи** становятся **столбцами**.
*   **Внутренние ключи** становятся **индексами** строк.

```python
population = {
    'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6},
    'Nevada': {2001: 2.4, 2002: 2.9}
}
df_nested = pd.DataFrame(population)
print(df_nested)
```
**Вывод:** (Обратите внимание, как Pandas автоматически выровнял данные и поставил `NaN`)
```
ㅤ       Ohio  Nevada
2000   1.5     NaN
2001   1.7     2.4
2002   3.6     2.9
```

**Присваивание с выравниванием по индексу (3.6.1):**
При попытке изменить столбец с помощью словаря или `Series`, Pandas будет ориентироваться на индекс. Если в `DataFrame` нет индекса из присваиваемого словаря, это значение будет проигнорировано.

**Пример:**
```python
df = pd.DataFrame({'A': [1, 2, 3]}, index=['a', 'b', 'c'])
update_dict = {'b': 200, 'd': 400} # 'd' - несуществующий индекс
df['A'] = pd.Series(update_dict)

print(df)
```
**Вывод:** (Значение для индекса 'd' было проигнорировано)
```
       A
a    NaN  # <-- Индекс 'a' не было в update_dict
b  200.0  # <-- Значение для 'b' обновилось
c    NaN  # <-- Индекс 'c' не было в update_dict
```

**Синтаксис присваивания (3.6.2, 3.6.3):**
*   Для присваивания можно использовать списки, `Series` и одномерные массивы `NumPy`.
*   **Важно:** Создавать новые столбцы можно **только** через синтаксис квадратных скобок `[]`. Через точку так сделать нельзя.
    ```python
    df['new_col_ok'] = 0      # Правильно, создаст новый столбец
    # df.new_col_fail = 0    # Неправильно, вызовет ошибку
    ```

---

#### 3.6.4 Удаление столбцов

Для удаления столбца используется оператор `del`. Он изменяет `DataFrame` на месте.

```python
del df['new_col_ok']
```

---

#### 3.6.6, 3.6.8 Транспонирование и доступ к данным

*   **Транспонирование (`.T`):**
    Атрибут `.T` меняет местами строки и столбцы. Это создает **новое представление** данных, не изменяя исходный `DataFrame`.
    ```python
    print(df_nested.T)
    ```
    **Вывод:**
    ```
    ㅤ         2000  2001  2002
    Ohioㅤ     1.5  ㅤ 1.7   3.6
    Nevada   NaN   2.4   2.9
    ```
*   **Доступ к "сырым" данным (`.values`):**
    Атрибут `.values` возвращает данные `DataFrame` в виде **двумерного массива NumPy**, без индексов и названий столбцов.
    ```python
    print(df_nested.values)
    # Вывод: array([[1.5, nan], [1.7, 2.4], [3.6, 2.9]])
    ```

---

#### 3.6.9-3.6.10 Объект `Index`

Индексные метки (и для строк, и для столбцов) хранятся в специальном объекте `pd.Index`.

**Ключевые свойства:**
1.  **Неизменяемость (Immutable):** Вы не можете изменить отдельный элемент индекса. Это обеспечивает безопасность данных и предсказуемость операций.
    ```python
    ind = pd.Index([1, 2, 3])
    # ind[0] = 99 # Вызовет TypeError
    ```
2.  **Похож на множество:** Поддерживает быстрый поиск и логические операции.
    ```python
    'Ohio' in df_nested.columns  # -> True
    2005 in df_nested.index    # -> False
    ```
3.  **Явное создание:** Можно создать объект `Index` и использовать его для создания `Series` или `DataFrame`.
    ```python
    my_index = pd.Index(['row1', 'row2', 'row3'])
    s = pd.Series([10, 20, 30], index=my_index)
    ```
