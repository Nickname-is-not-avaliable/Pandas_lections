### 5.4 Определяем выбросы и грамотно устраняем их

---
#### 5.4.1-5.4.4 Обнаружение и фильтрация выбросов

**1. Анализ с помощью `.describe()`**
Первый шаг в поиске выбросов — посмотреть на описательные статистики. Большой разрыв между `75%` (75-й перцентиль) и `max`, или между `min` и `25%`, часто указывает на наличие выбросов.

**--- Исходные данные ---**
```python
df = pd.DataFrame(np.random.randn(100, 4), columns=list('ABCD'))
df.iloc[0, 2] = 100 # Искусственно создаем выброс

print("Описательные статистики:")
print(df.describe())
```
**Вывод:** (Обратите внимание на `max` в столбце `C`, который сильно отличается от `75%`)
```
Описательные статистики:
                A           B           C           D
count  100.000000  100.000000  100.000000  100.000000
mean     0.052029   -0.015248    1.009407    0.024225
std      0.989262    1.011283   10.040187    0.985869
min     -2.457805   -2.585573   -2.228800   -2.271378
25%     -0.613329   -0.709322   -0.651785   -0.589839
50%      0.038234    0.014285   -0.014383    0.038481
75%      0.716244    0.697410    0.627705    0.694605
max      2.589524    2.463248  100.000000    2.536762
```
---
**2. Создание маски и фильтрация**
Мы можем создать булеву маску для поиска значений, выходящих за определенные пределы (например, более 3-х стандартных отклонений от среднего).

```python
# Находим все ячейки, где абсолютное значение > 3
mask = np.abs(df) > 3
print("\nДвумерная маска (True - выброс):")
print(mask.head())

# Сжимаем маску до 1D Series, чтобы найти строки,
# в которых есть хотя бы один выброс
rows_with_outliers = mask.any(axis=1)
print("\nСтроки с выбросами:")
print(df[rows_with_outliers])

# Фильтруем DataFrame, оставляя только "чистые" строки
df_cleaned = df[~rows_with_outliers]
print("\nDataFrame после удаления строк с выбросами:")
print(f"Исходный размер: {df.shape}, После очистки: {df_cleaned.shape}")
```
**Вывод:**
```
Двумерная маска (True - выброс):
       A      B      C      D
0  False  False   True  False
1  False  False  False  False
2  False  False  False  False
3  False  False  False  False
4  False  False  False  False

Строки с выбросами:
          A         B      C         D
0 -0.507851 -0.420658  100.0 -0.563844

DataFrame после удаления строк с выбросами:
Исходный размер: (100, 4), После очистки: (99, 4)
```

---
#### 5.4.5-5.4.8 Замена и ограничение выбросов

Вместо удаления, выбросы можно заменить или "срезать".

**1. Замена по маске**
```python
# Заменяем все выбросы (> 3) на NaN
df_with_nan = df.copy()
df_with_nan[mask] = np.nan
print("DataFrame после замены выбросов на NaN:")
print(df_with_nan.head())
```

**2. Использование `np.sign` и `.clip()`**
*   `np.sign(df)`: Возвращает `DataFrame` той же формы, где `1` — для положительных чисел, `-1` — для отрицательных, `0` — для нуля. Полезно для "срезания" значений до определенного порога, сохраняя их знак.
*   `.clip(lower, upper)`: Ограничивает значения в `DataFrame`. Всё, что меньше `lower`, становится `lower`. Всё, что больше `upper`, становится `upper`.

**--- Исходные данные ---**
```python
df_clip_test = pd.DataFrame({'A': [-100, 0, 100], 'B': [5, -5, 0]})
print("Исходный DataFrame для .clip():")
print(df_clip_test)
```
**Вывод:**
```
Исходный DataFrame для .clip():
     A  B
0 -100  5
1    0 -5
2  100  0
```

**--- Применение функций ---**
```python
# Пример с np.sign: заменим все выбросы на +/- 3
df_signed = df.copy()
df_signed[mask] = np.sign(df_signed) * 3
print("\nDataFrame после замены выбросов на +/-3:")
print(df_signed.head())

# Пример с .clip(): ограничим все значения в диапазоне [-2, 2]
df_clipped = df.clip(-2, 2)
print("\nDataFrame после .clip(-2, 2):")
print(df_clipped.describe()) # .describe() показывает, что min/max теперь в пределах [-2, 2]
```
---
#### 5.4.9 Перемешивание и случайная выборка

**1. Перемешивание с `np.random.permutation` и `.take()`**
Этот способ позволяет полностью перемешать строки `DataFrame`.

```python
# 1. Создаем случайную перестановку индексов от 0 до N-1
shuffled_indices = np.random.permutation(len(df))

# 2. Используем .take() для переупорядочивания строк по новым индексам
df_shuffled = df.take(shuffled_indices)
print("Перемешанный DataFrame:")
print(df_shuffled.head())
```

**2. Случайная выборка с `.sample()`**
`.sample()` — это более удобный и гибкий способ получить случайное подмножество данных.

```python
# Получить 5 случайных строк (без повторений)
random_sample = df.sample(n=5)
print("\nСлучайная выборка 5 строк:")
print(random_sample)

# Получить 10% от всех строк с возможностью повторов
random_fraction_with_replace = df.sample(frac=0.1, replace=True)
print(f"\nСлучайная выборка 10% строк с повторами (размер: {len(random_fraction_with_replace)}):")
```
