### 2.13.1 Логические проверки для всего массива: `any` и `all`

Эти методы применяются к булевым массивам для их быстрой проверки.

*   `arr.any()`: Возвращает `True`, если в массиве есть **хотя бы один** `True`.
*   `arr.all()`: Возвращает `True`, только если **все элементы** в массиве `True`.

---

### 2.13.2-2.13.3 Сортировка массивов

*   **Метод `.sort()`:**
    `arr.sort()` сортирует массив **на месте** (in-place), то есть изменяет исходный массив и ничего не возвращает (`None`).

*   **Сортировка многомерных массивов:**
    С помощью параметра `axis` можно указать направление сортировки.
    ```python
    arr = np.array([[9, 2, 5], [4, 8, 1]])
    print("Исходный массив:\n", arr)
    ```
    *   **`axis=1` (по умолчанию):** сортировка **вдоль строк**. Каждый столбец рассматривается как независимый набор данных.
        ```python
        arr_sorted_rows = arr.copy()
        arr_sorted_rows.sort(axis=1)
        print("\nСортировка по строкам (axis=1):\n", arr_sorted_rows)
        # [[2, 5, 9], 
        #   [1, 4, 8]]
        ```
    *   **`axis=0`:** сортировка **вдоль столбцов**. Каждая строка рассматривается как независимый набор данных.
        ```python
        arr_sorted_cols = arr.copy()
        arr_sorted_cols.sort(axis=0)
        print("\nСортировка по столбцам (axis=0):\n", arr_sorted_cols)
        # [[4, 2, 1], 
        #   [9, 8, 5]]
        ```

---

### 2.13.4-2.13.5 Операции над множествами

*   **`np.unique(arr)`**: Возвращает новый отсортированный массив, содержащий только **уникальные** элементы из `arr`.

*   **`np.in1d(arr1, arr2)`**: Проверяет, какие элементы из `arr1` содержатся в `arr2`. Возвращает **булеву маску** длиной с `arr1`.

---

### 2.13.6-2.13.8 Операции из линейной алгебры

Большинство этих функций находятся в подмодуле `np.linalg`.

*   **Матричное умножение:** `np.dot(arr1, arr2)` или `arr1 @ arr2`.
*   **Определитель (детерминант):** `np.linalg.det(arr)`
*   **Обратная матрица:** `np.linalg.inv(arr)`

*   **Работа с диагоналями:**
    *   **Извлечение диагонали:** `np.diag(arr, k=0)`
        `k` — сдвиг относительно главной диагонали: `k=0` (главная), `k=1` (над главной), `k=-1` (под главной).
    *   **Сумма элементов главной диагонали (след матрицы):** `np.trace(arr)`

*   **Треугольные матрицы:**
    *   **Верхнетреугольная:** `np.triu(arr)` (всё, что ниже главной диагонали, зануляется).
    *   **Нижнетреугольная:** `np.tril(arr)` (всё, что выше главной диагонали, зануляется).

**Пример для `np.diag`:**
Представьте, у нас есть матрица 4x4, где числа специально подобраны так, чтобы было легко отследить их положение:

```python
# Создадим более наглядную матрицу 4x4
# Первое число - номер строки, второе - номер столбца
matrix = np.array([
    [11, 12, 13, 14],  
    [21, 22, 23, 24],  
    [31, 32, 33, 34],  
    [41, 42, 43, 44]   
])

print("Исходная матрица:\n", matrix)
```

Теперь посмотрим, как параметр `k` влияет на то, какая диагональ будет извлечена:

**Главная диагональ (`k=0`, по умолчанию)**
Это диагональ, идущая из левого верхнего угла в правый нижний.

```python
# k=0: Элементы, где номер строки равен номеру столбца
# (0,0), (1,1), (2,2), (3,3)
main_diag = np.diag(matrix, k=0)
print("\nГлавная диагональ (k=0):", main_diag)
# Вывод: [11 22 33 44]
```

**Диагонали НАД главной (`k > 0`)**
Это диагонали, которые смещены вверх-вправо относительно главной.

```python
# k=1: Сдвиг на 1 шаг вверх от главной диагонали
# Элементы: (0,1), (1,2), (2,3)
upper_diag = np.diag(matrix, k=1)
print("Диагональ выше главной (k=1):", upper_diag)
# Вывод: [12 23 34]

# k=2: Сдвиг на 2 шага вверх
# Элементы: (0,2), (1,3)
upper_diag_2 = np.diag(matrix, k=2)
print("Диагональ со сдвигом k=2:", upper_diag_2)
# Вывод: [13 24]
```

**Диагонали ПОД главной (`k < 0`)**
Это диагонали, которые смещены вниз-влево относительно главной.

```python
# k=-1: Сдвиг на 1 шаг вниз от главной диагонали
# Элементы: (1,0), (2,1), (3,2)
lower_diag = np.diag(matrix, k=-1)
print("Диагональ ниже главной (k=-1):", lower_diag)
# Вывод: [21 32 43]

# k=-2: Сдвиг на 2 шага вниз
# Элементы: (2,0), (3,1)
lower_diag_2 = np.diag(matrix, k=-2)
print("Диагональ со сдвигом k=-2:", lower_diag_2)
# Вывод: [31 42]
```

Ключ к пониманию — **`k` это "сдвиг" от главной диагонали**:
*   `k=0` — это центр.
*   Положительный `k` — сдвиг вправо.
*   Отрицательный `k` — сдвиг вниз.

---

### 2.13.9-2.13.10 Генерация случайных данных: `np.random`

Этот подмодуль содержит функции для создания массивов со случайными числами.

*   **`np.random.randint(low, high, size)`:**
    Создает массив случайных **целых чисел**.
    *   `low`: Минимальное значение (включительно).
    *   `high`: Максимальное значение (**не** включительно).
    *   `size`: Форма массива. Может быть числом (для 1D) или кортежем (для ND).

**Пример:**
```python
# Создать 1D массив из 5 случайных чисел от 0 до 9
arr_1d = np.random.randint(0, 10, 5)

# Создать матрицу 3x4 из случайных чисел от 0 до 99
arr_2d = np.random.randint(0, 100, (3, 4))
```
