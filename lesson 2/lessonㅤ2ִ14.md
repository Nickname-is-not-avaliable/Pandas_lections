### 2.14.1-2.14.2 Перемешивание элементов

NumPy предоставляет два основных способа для случайного перемешивания данных:

*   **`np.random.permutation(n)`:**
    **Создает новый** массив с числами от `0` до `n-1`, расположенными в случайном порядке. Исходные данные не затрагиваются.
    ```python
    # Создаст новый массив, например [2, 0, 3, 1]
    shuffled_sequence = np.random.permutation(4) 
    ```

*   **`np.random.shuffle(arr)`:**
    Перемешивает существующий массив `arr` **на месте** (in-place). Функция ничего не возвращает (`None`).
    ```python
    my_array = np.arange(5) # -> [0, 1, 2, 3, 4]
    np.random.shuffle(my_array)
    # Теперь my_array, например, [3, 1, 4, 0, 2]
    ```

---

### 2.14.3-2.14.4 Генерация данных из нормального распределения

*   **`np.random.randn(d1, d2, ...)`:**
    Создает массив указанной формы, заполненный случайными числами типа `float` из **стандартного нормального ("гауссова") распределения**.
    *   *Среднее значение (математическое ожидание)* ≈ 0
    *   *Стандартное отклонение* ≈ 1

**Важная особенность синтаксиса:** В отличие от других функций, `randn` принимает размеры не кортежем, а как отдельные аргументы.

```python
# Создаст 1D массив из 5 элементов
arr_1d = np.random.randn(5)

# Создаст матрицу 2x3
# Правильно: np.random.randn(2, 3)
# Неправильно: np.random.randn((2, 3))
arr_2d = np.random.randn(2, 3)
```

---

### 2.14.5 Сохранение и загрузка одного массива (`.npy`)

*   **`np.save(filename, arr)`:**
    Сохраняет один массив `arr` в двоичный файл. Если не указать расширение, по умолчанию будет добавлено `.npy`.

*   **`np.load(filename)`:**
    Загружает массив из файла. **Важно:** при загрузке необходимо указывать полное имя файла, включая расширение.

---

### 2.14.6-2.14.7 Сохранение и загрузка нескольких массивов (`.npz`)

Для сохранения нескольких массивов в один файл используются функции, создающие архивы `.npz`.

*   **`np.savez(filename, name1=arr1, name2=arr2, ...)`:**
    Сохраняет несколько массивов в **не сжатый** архив. Каждый массив сохраняется под именем, которое вы ему присваиваете (как в словаре).

*   **`np.savez_compressed(filename, name1=arr1, ...)`:**
    Делает то же самое, но использует **сжатие**, что позволяет экономить место на диске.

**Загрузка из `.npz` архива:**
При загрузке `.npz` файла с помощью `np.load()` возвращается специальный объект `NpzFile`, который ведет себя как словарь.

**Важная особенность:** Данные из `.npz` архивов загружаются **"лениво" (lazily)**. Это значит, что массив считывается с диска в память только в тот момент, когда вы к нему обращаетесь по ключу. Это очень эффективно при работе с большими файлами.

**Пример:**
```python
arr1 = np.arange(10)
arr2 = np.random.randn(3, 3)

# Сохраняем в сжатый архив
np.savez_compressed('my_archive.npz', first_array=arr1, second_array=arr2)

# Загружаем "контейнер"
data = np.load('my_archive.npz')

# Обращаемся к массивам по ключам
print("Первый массив:\n", data['first_array'])
print("\nВторой массив:\n", data['second_array'])

# Если просто напечатать объект data, будет нечитаемая информация
# print(data) 
```
