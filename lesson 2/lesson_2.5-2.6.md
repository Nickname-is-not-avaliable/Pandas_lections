### 2.5.1 Копирование массивов (Copies vs Views)

По умолчанию срезы создают "представление" (view), а не копию. Чтобы создать полную независимую копию массива или его части, используйте метод `.copy()`:

```python
# arr_copy будет независимой копией среза arr[a:n]
arr_copy = arr[a:n].copy()

# Изменения в arr_copy не затронут исходный массив arr
arr_copy[0] = 999
```

---

### 2.5.2 Виды записи индексов

Для многомерных массивов оба варианта обращения к элементам эквивалентны:
*   **Через запятую (предпочтительно):** `arr[x, y]`
*   **Поочередно:** `arr[x][y]`

---

### 2.5.3-2.5.4 Трёхмерные массивы

Трёхмерный массив можно представить как набор (стопку) двумерных матриц.

**Пример:**
```python
arr_3d = np.array([
    # Блок 0
    [[ 1,  2,  3],
     [ 4,  5,  6],
     [ 7,  8,  9],
     [10, 11, 12]],
    
    # Блок 1
    [[13, 14, 15],
     [16, 17, 18],
     [19, 20, 21],
     [22, 23, 24]]
])
```
*   **Форма (shape) этого массива:** `(2, 4, 3)`
*   **Расшифровка:** 2 блока, в каждом из которых 4 строки и 3 столбца.

**2.5.5** Обращение к `arr_3d[0]` вернёт первый блок — то есть, двумерный массив (матрицу) размером `(4, 3)`.

---

### 2.5.6-2.5.8 Продвинутые срезы (Slicing)

*   **Обращение к одному столбцу:** `arr[:, a]`
    ( `:` означает "взять все строки", `a` — индекс нужного столбца)
*   **Обращение к нескольким столбцам:** `arr[:, a:n]`
*   **Вырезать "подматрицу" (часть массива):** `arr[a1:n1, a2:n2]`

---

### 2.5.9 Булевы маски (Boolean Masking)

Маска — это массив из `True` и `False`, который используется для выбора элементов из другого массива.

*   Элементы, для которых в маске стоит `True`, будут выбраны.
*   Элементы, для которых в маске `False`, будут проигнорированы.

**Важно:** При индексации по маске всегда создается **копия** данных.

**Пример:**
```python
arr1 = np.array([1, 2, 3])
mask = [True, False, True]

# arr2 будет содержать только элементы arr1, где в mask было True
arr2 = arr1[mask]  # arr2 станет [1, 3]

# Изменяем arr2
arr2[0] = 999      # arr2 станет [999, 3]

# arr1 при этом не изменится
print(arr1)  # Вывод: [1 2 3]
```

**2.5.10-2.5.11** Маски можно создавать "на лету" с помощью логических условий:
```python
# Создаст маску, где True будет для всех элементов arr, которые больше x
mask = arr > x

# Можно сразу применить эту маску для фильтрации
large_elements = arr[arr > x]
```
Это работает для всех операторов сравнения: `<`, `>`, `==`, `!=` и т.д.
