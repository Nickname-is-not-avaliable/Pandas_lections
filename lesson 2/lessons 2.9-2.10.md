### 2.9.1-2.9.2 Представления (Views) vs Копии: `reshape`

Функция `.reshape()` **не создает новый массив**, а лишь меняет "представление" (view) исходных данных. Это означает, что новый и старый массив используют одну и ту же область памяти.

*   **Следствие:** При изменении данных в одном массиве, они изменятся и в другом.
*   **Причина:** Это сделано для экономии памяти и высокой производительности, так как не происходит копирования данных.

---

### 2.9.3 Транспонирование матрицы

Транспонирование меняет строки и столбцы местами. Как и `reshape`, эта операция создает **представление**, а не копию.

*   **Синтаксис (атрибут):** `arr.T`
*   **Синтаксис (метод):** `arr.transpose()`

---

### 2.9.4-2.9.5 Унарные математические функции (ufunc)

Эти функции выполняют поэлементные операции над одним массивом.

*   **Корень квадратный:** `np.sqrt(arr)`
*   **Модуль (абсолютное значение):** `np.abs(arr)`
*   **Округление до ближайшего целого:** `np.round(arr)`
    *(Примечание: `0.5` округляется до ближайшего четного числа, например, `2.5 -> 2`, `3.5 -> 4`)*
*   **Округление вверх (потолок):** `np.ceil(arr)`
*   **Округление вниз (пол):** `np.floor(arr)`

---

### 2.9.6 Работа с `NaN` и `inf` *(Пункт с inf можно найти в конце 10 лекции. Сгруппировал так из-за близости тем.)*

*   **Проверка на `NaN`:** `np.isnan(arr)`
*   **Проверка на бесконечность:** `np.isinf(arr)`

Обе функции возвращают булеву маску. NumPy обычно не выдает ошибок при вычислениях с `NaN`, а "распространяет" его дальше (например, `5 + np.nan` будет `nan`).

---

### 2.9.7 Параметр `out`

Многие функции NumPy принимают необязательный параметр `out`, который позволяет записать результат операции в уже существующий массив, вместо создания нового. Это помогает экономить память.

```python
arr1 = np.array([1, 2, 3])
arr2 = np.zeros_like(arr1) # Создаем массив-приемник той же формы

# Вместо arr2 = np.abs(arr1), делаем так:
np.abs(arr1, out=arr2) 
# Теперь arr2 содержит результат [1, 2, 3]
```

---

### 2.9.8-2.9.10 Бинарные математические функции

Эти функции выполняют поэлементные операции над двумя массивами. **Важно:** массивы должны быть одинаковой длины (или совместимы по правилам [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)).

*   **Поэлементный максимум:** `np.maximum(arr1, arr2)`
*   **Поэлементный минимум:** `np.minimum(arr1, arr2)`

**Арифметические операции:**
Хотя для всех арифметических операций существуют функции, на практике почти всегда используются стандартные операторы, так как это короче и читабельнее.

*   **Сложение:** `np.add(arr1, arr2)` эквивалентно `arr1 + arr2`
*   **Вычитание:** `np.subtract(arr1, arr2)` эквивалентно `arr1 - arr2`
*   **Умножение:** `np.multiply(arr1, arr2)` эквивалентно `arr1 * arr2`
*   **Деление:** `np.divide(arr1, arr2)` эквивалентно `arr1 / arr2`
